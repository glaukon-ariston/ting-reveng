/DSCDecode/net.anastigmatix.filter resourcestatus{ pop % 146
 2 % 136
 lt % 146
{ currentfile % 146
 flushfile % 146
} if % 146
} if % 146
 32 % 136
 dict % 146
 begin % 146
currentpacking //true % 141
setpacking currentglobal % 146
 //true % 141
 setglobal % 146
/CR (\r) % 142
readonly def % 146
/LF (\n) % 142
readonly def % 146
/SP ( ) % 142
readonly def % 146
/HT (\t) % 142
readonly def % 146
/: (:) % 142
readonly def % 146
/L+ (%%+) % 142
readonly def % 146
/.spre{ exch % 146
{ search % 146
{ 6 % 136
 2 % 136
 roll % 146
 pop % 146
 pop % 146
 pop % 146
 1 % 136
 index % 146
 length % 146
 1 % 136
 add % 146
 1 % 136
 index % 146
 length % 146
 1 % 136
 index % 146
 sub % 146
 getinterval % 146
 3 % 136
 1 % 136
 roll % 146
}{ 4 % 136
 -1 % 136
 roll % 146
 pop % 146
} ifelse % 146
 //true % 141
}{ exch % 146
 pop % 146
 search % 146
} ifelse % 146
} bind % 146
 def % 146
/.sphtsearch{ dup % 146
//SP search % 146
//HT//.spre exec % 146
} bind % 146
 def % 146
/.spht:search{ dup % 146
//.sphtsearch exec % 146
//://.spre exec % 146
} bind % 146
 def % 146
/.spht:crlf{ dup % 146
 dup % 146
//.spht:search exec % 146
//LF//.spre exec % 146
//CR//.spre exec % 146
} bind % 146
 def % 146
/.DSCsplit{ dup % 146
//.spht:crlf exec % 146
{ exch % 146
//: eq % 146
{ length % 146
 1 % 136
 add % 146
 3 % 136
 -1 % 136
 roll % 146
 exch % 146
 0 % 136
 exch % 146
 getinterval % 146
}{ exch % 146
 pop % 146
 exch % 146
 1 % 136
 index % 146
 length % 146
 1 % 136
 index % 146
 length % 146
 1 % 136
 index % 146
 sub % 146
 getinterval % 146
 exch % 146
} ifelse % 146
}{ pop % 146
 () % 142
 exch % 146
} ifelse % 146
} bind % 146
 def % 146
/.pba{ pbf dup % 146
 3 % 136
 get % 146
 2 % 136
 copy % 146
 1 % 136
 add % 146
 3 % 136
 exch % 146
 put % 146
 neg % 146
 2 % 136
 add % 146
 3 % 136
 -1 % 136
 roll % 146
 put % 146
} bind % 146
 def % 146
false setpacking/.pbr{ pbf 3 % 136
 get % 146
 0 % 136
 gt % 146
{pbf dup % 146
 3 % 136
 get % 146
 1 % 136
 sub % 146
 2 % 136
 copy % 146
 3 % 136
 exch % 146
 put % 146
 neg % 146
 2 % 136
 add % 146
 get % 146
 //true % 141
}{src read % 146
} ifelse % 146
} bind % 146
 def % 146
true setpacking/.pblf{/countlf //true % 141
 def % 146
//.pbr exec % 146
{ dup % 146
 10 % 136
 ne % 146
//.pba{ buf exch % 146
col exch % 146
 put % 146
/col col 1 % 136
 add % 146
 def % 146
 exch % 146
 pop % 146
 exch % 146
 pop % 146
buf 0 % 136
col getinterval % 146
 exch % 146
 2 % 136
 copy % 146
 length % 146
 1 % 136
 index % 146
 length % 146
 1 % 136
 index % 146
 sub % 146
 getinterval % 146
 exch % 146
} ifelse % 146
} if % 146
} bind % 146
 def % 146
/.pb+{ //false % 141
mark//.pbr exec % 146
{ dup % 146
 37 % 136
 eq % 146
{//.pbr exec % 146
{ dup % 146
 37 % 136
 eq % 146
{//.pbr exec % 146
{ dup % 146
 43 % 136
 eq % 146
{ pop % 146
 pop % 146
 pop % 146
 pop % 146
 pop % 146
 //true % 141
mark} if % 146
} if % 146
} if % 146
} if % 146
} if % 146
} if % 146
 counttomark % 146
//.pba repeat % 146
 pop % 146
} bind % 146
 def % 146
/.trnl{ exch % 146
 0 % 136
 1 % 136
 index % 146
 dup % 146
 length % 146
 dup % 146
 2 % 136
 ge % 146
{ 2 % 136
 sub % 146
 2 % 136
 getinterval % 146
{} forall % 146
}{ 1 % 136
 eq % 146
{ 0 % 136
 get % 146
}{ pop % 146
 0 % 136
} ifelse % 146
 0 % 136
 exch % 146
} ifelse % 146
 dup % 146
 13 % 136
 eq % 146
{ pop % 146
 pop % 146
 -1 % 136
}{ 10 % 136
 ne % 146
{ pop % 146
 0 % 136
}{ 13 % 136
 eq % 146
{ -2 % 136
}{ -1 % 136
} ifelse % 146
} ifelse % 146
} ifelse % 146
 2 % 136
 index % 146
 length % 146
 add % 146
 getinterval % 146
 exch % 146
} bind % 146
 def % 146
/.dlsc{ dup % 146
 length % 146
 string % 146
 copy % 146
} bind % 146
 def % 146
/.gac{ buf 0 % 136
col getinterval % 146
} bind % 146
 def % 146
/.glom{//.dlsc exec % 146
 3 % 136
 1 % 136
 roll % 146
//.dlsc exec % 146
 exch % 146
//.dlsc exec % 146
/acc load % 146
[ 4 % 136
 2 % 136
 roll % 146
/acc//.gac def % 146
/EOD //false % 141
 def % 146
{/col 0 % 136
 def % 146
rda dup % 146
 () % 142
countlf not % 146
//.pblf if % 146
 pop % 146
 pop % 146
//.dlsc exec % 146
 dup % 146
 () % 142
//.trnl exec % 146
 pop % 146
 exch % 146
//.pb+ exec % 146
 not % 146
{ exit % 146
} if % 146
} loop % 146
] exch % 146
/EOD //true % 141
 def % 146
/acc exch % 146
 def % 146
 0 % 136
 0 % 136
 2 % 136
 index % 146
{ length % 146
 add % 146
 exch % 146
} forall % 146
 2 % 136
 index % 146
 length % 146
 2 % 136
 idiv % 146
 1 % 136
 sub % 146
 exch % 146
 1 % 136
 index % 146
 add % 146
 3 % 136
 1 % 136
 roll % 146
 3 % 136
 mul % 146
 add % 146
 exch % 146
 currentglobal % 146
 3 % 136
 1 % 136
 roll % 146
sta gcheck setglobal % 146
 string % 146
 exch % 146
 string % 146
 3 % 136
 -1 % 136
 roll % 146
 setglobal % 146
 2 % 136
{ 1 % 136
 index % 146
/NullEncode filter % 146
} repeat % 146
{{ 3 % 136
 index % 146
 dup % 146
//L+ writestring % 146
 exch % 146
 writestring % 146
 3 % 136
 index % 146
 dup % 146
 10 % 136
 write % 146
 exch % 146
 writestring % 146
 dup % 146
}}{{ 3 % 136
 index % 146
 exch % 146
 writestring % 146
 3 % 136
 index % 146
 exch % 146
 writestring % 146
 dup % 146
}} 7 % 136
 -1 % 136
 roll % 146
{ exch % 146
 exec % 146
} forall % 146
 pop % 146
 pop % 146
closefile closefile exch % 146
 3 % 136
 -1 % 136
 roll % 146
} bind % 146
 def % 146
/.etd{/EOD //true % 141
 def % 146
pbf wcheck{ countlf not % 146
//.pblf if % 146
} if % 146
sta null % 146
 eq % 146
{ pop % 146
 pop % 146
}{//.trnl exec % 146
pbf wcheck{ 1 % 136
 index % 146
 () % 142
 ne % 146
{ 1 % 136
 index % 146
 0 % 136
 get % 146
 dup % 146
 10 % 136
 ne % 146
 exch % 146
 13 % 136
 ne % 146
 and % 146
{//.pb+ exec % 146
//.glom if % 146
} if % 146
} if % 146
} if % 146
 exch % 146
 3 % 136
 -1 % 136
 roll % 146
nest sta astore % 146
 pop % 146
 () % 142
} ifelse % 146
} bind % 146
 def % 146
/.dscp << (%%EndComments) % 142
readonly{ hdr nest 1 % 136
 eq % 146
 and % 146
//.etd{ pop % 146
 pop % 146
} ifelse % 146
} bind % 146
 (%%BeginData:) % 142
readonly{ pop % 146
 token % 146
{ dup % 146
 type % 146
/integertype ne % 146
{ pop % 146
 pop % 146
}{ exch % 146
 token % 146
{ dup % 146
/Bytes eq % 146
 1 % 136
 index % 146
/Lines eq % 146
 or % 146
{ exch % 146
 pop % 146
}{ pop % 146
 token % 146
{ exch % 146
 pop % 146
}{/Bytes} ifelse % 146
} ifelse % 146
}{/Bytes} ifelse % 146
/Lines eq % 146
{line add % 146
/rawtoline exch % 146
 def % 146
}{ dup % 146
 0 % 136
 gt % 146
{/rd/rdb load % 146
 def % 146
} if % 146
/rawbytes exch % 146
 def % 146
} ifelse % 146
} ifelse % 146
} if % 146
} bind % 146
 (%%BeginDocument:) % 142
readonly{ pop % 146
 pop % 146
/nest nest 1 % 136
 add % 146
 def % 146
uwp line 1 % 136
 eq % 146
nest 1 % 136
 eq % 146
 and % 146
 and % 146
{/sprs //true % 141
 def % 146
} if % 146
} bind % 146
 (%%EndDocument) % 142
readonly{ nest 1 % 136
 sub % 146
 dup % 146
/nest exch % 146
 def % 146
 0 % 136
 ne % 146
{ pop % 146
 pop % 146
}{//.etd exec % 146
uwp{/sprs //true % 141
 def % 146
} if % 146
} ifelse % 146
} bind % 146
>> readonly def % 146
/.chk{ dup % 146
 length % 146
 2 % 136
 gt % 146
{ dup % 146
 0 % 136
 get % 146
 37 % 136
 eq % 146
{ dup % 146
//.DSCsplit exec % 146
 2 % 136
 copy % 146
 5 % 136
 2 % 136
 roll % 146
//.dscp 1 % 136
 index % 146
 2 % 136
 copy % 146
 known % 146
{ get % 146
 exec % 146
}{ pop % 146
 pop % 146
 pop % 146
 pop % 146
} ifelse % 146
 3 % 136
 -2 % 136
 roll % 146
nest 1 % 136
 ne % 146
{ pop % 146
 pop % 146
}{kwd 1 % 136
 index % 146
 known % 146
//.etd{ pop % 146
 pop % 146
} ifelse % 146
} ifelse % 146
} if % 146
} if % 146
} bind % 146
 def % 146
/.ec0{ dup % 146
 () % 142
//.etd exec % 146
} bind % 146
 def % 146
/.eck{ dup % 146
 length % 146
 2 % 136
 lt % 146
//.ec0{ dup % 146
 0 % 136
 get % 146
 37 % 136
 ne % 146
//.ec0{ dup % 146
 1 % 136
 get % 146
 dup % 146
 33 % 136
 lt % 146
 exch % 146
 126 % 136
 gt % 146
 or % 146
//.ec0 if % 146
} ifelse % 146
} ifelse % 146
} bind % 146
 def % 146
/.acc{//.gac exec % 146
incomp{/incomp //false % 141
 def % 146
/contin //true % 141
 def % 146
hdr//.eck if % 146
}{contin{/contin //false % 141
 def % 146
}{line rawtoline gt % 146
{//.chk exec % 146
uwp line 1 % 136
 eq % 146
nest 0 % 136
 eq % 146
 and % 146
 and % 146
{/nest 1 % 136
 def % 146
} if % 146
EOD not % 146
{hdr//.eck if % 146
} if % 146
} if % 146
} ifelse % 146
} ifelse % 146
/col 0 % 136
 def % 146
} bind % 146
 def % 146
false setpacking/.rda{{ EOD{ () % 142
 exit % 146
} if % 146
//.pbr exec % 146
 not % 146
{acc exit % 146
} if % 146
buf col 2 % 136
 index % 146
 put % 146
/col col 1 % 136
 add % 146
 def % 146
 dup % 146
 10 % 136
 eq % 146
{countlf{/line line 1 % 136
 add % 146
 def % 146
} if % 146
 pop % 146
acc exit % 146
}{ 13 % 136
 eq % 146
{/line line 1 % 136
 add % 146
 def % 146
/countlf //false % 141
 def % 146
acc exit % 146
}{col 255 % 134
 gt % 146
{/incomp //true % 141
 def % 146
acc exit % 146
} if % 146
} ifelse % 146
} ifelse % 146
/countlf //true % 141
 def % 146
} loop % 146
sprs{ pop % 146
/sprs //false % 141
 def % 146
rda} if % 146
} bind % 146
 def % 146
true setpacking/.rdb{ src buf rawbytes 255 % 134
 lt % 146
{ 0 % 136
rawbytes getinterval % 146
} if % 146
 readstring % 146
 pop % 146
 dup % 146
 length % 146
countlf not % 146
{ dup % 146
 1 % 136
 ge % 146
{ 1 % 136
 index % 146
 0 % 136
 get % 146
 10 % 136
 eq % 146
{ 1 % 136
 sub % 146
} if % 146
} if % 146
} if % 146
/countlf //true % 141
 def % 146
/rawbytes exch % 146
rawbytes exch % 146
 sub % 146
 dup % 146
 0 % 136
 eq % 146
{/rd/rda load % 146
 def % 146
} if % 146
 def % 146
} bind % 146
 def % 146
/.dsp{ 1 % 136
 get % 146
 begin % 146
{rd} stopped % 146
 end % 146
{ stop % 146
} if % 146
} bind % 146
 def % 146
/.mtd 0 % 136
 dict % 146
readonly def % 146
/.mtpb 4 % 136
 string % 146
readonly def % 146
 setglobal % 146
/.dfg{ 2 % 136
 copy % 146
 known % 146
{ get % 146
 exch % 146
 pop % 146
}{ pop % 146
 pop % 146
} ifelse % 146
} bind % 146
 def % 146
/DSCDecode{ dup % 146
/Status 2 % 136
 copy % 146
 known % 146
{ get % 146
 0 % 136
 4 % 136
 getinterval % 146
}{ pop % 146
 pop % 146
 null % 146
} ifelse % 146
 3 % 136
 -1 % 136
 roll % 146
 dup % 146
 type % 146
/filetype ne % 146
{ 0 % 136
 () % 142
/SubFileDecode filter % 146
} if % 146
//.mtpb 3 % 136
 index % 146
/Pushback//.dfg exec % 146
 0 % 136
 4 % 136
 getinterval % 146
 4 % 136
 1 % 136
 roll % 146
 1 % 136
 index % 146
gcheck 1 % 136
 index % 146
gcheck and % 146
 4 % 136
 index % 146
gcheck and % 146
 setglobal % 146
 2 % 136
 index % 146
/Keywords 2 % 136
 copy % 146
 known % 146
{ get % 146
 dup % 146
 type % 146
/dicttype ne % 146
{<< exch % 146
{ cvn % 146
 null % 146
} forall % 146
>>} if % 146
}{ pop % 146
 pop % 146
//.mtd} ifelse % 146
<</kwd 3 % 136
 -1 % 136
 roll % 146
/src 5 % 136
 -1 % 136
 roll % 146
/sta 7 % 136
 -1 % 136
 roll % 146
/nest 0 % 136
 9 % 136
 index % 146
/NestDepth//.dfg exec % 146
/countlf //true % 141
 11 % 136
 index % 146
/CountLF//.dfg exec % 146
/hdr //false % 141
 13 % 136
 index % 146
/HeaderOnly//.dfg exec % 146
/uwp //false % 141
 15 % 136
 index % 146
/Unwrap//.dfg exec % 146
/pbf 18 % 136
 -1 % 136
 roll % 146
/buf 257 % 134
 string % 146
/line 0 % 136
/col 0 % 136
/rawbytes 0 % 136
/rawtoline 0 % 136
/incomp //false % 141
/contin //false % 141
/EOD //false % 141
/rda//.rda/rdb//.rdb/rd//.rda/acc//.acc/sprs //false % 141
>> exch % 146
 pop % 146
//.dsp exch % 146
 2 % 136
 array % 146
 astore % 146
/Decode} bind % 146
 def % 146
setpacking/DSCDecode dup % 146
 load % 146
/net.anastigmatix.filter defineresource pop % 146
 end % 146
