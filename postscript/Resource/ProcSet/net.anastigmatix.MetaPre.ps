/net.anastigmatix.MetaPre/ProcSet resourcestatus{ pop % 146
 2 % 136
 lt % 146
{ currentfile % 146
 flushfile % 146
} if % 146
} if % 146
 42 % 136
 dict % 146
 begin % 146
currentpacking //true % 141
setpacking currentglobal % 146
 //true % 141
 setglobal % 146
/.hy (-) % 142
readonly def % 146
/.vb (|) % 142
readonly def % 146
/.erst{ //false % 141
 setglobal % 146
//systemdict/$error get % 146
 begin % 146
/newerror //true % 141
 def % 146
/errorname exch % 146
 def % 146
/command exch % 146
 def % 146
/errorinfo null % 146
 def % 146
recordstacks{ count % 146
 array % 146
 astore % 146
 aload % 146
/ostack exch % 146
 def % 146
countexecstack array % 146
execstack dup % 146
 length % 146
 1 % 136
 sub % 146
 0 % 136
 exch % 146
 getinterval % 146
/estack exch % 146
 def % 146
countdictstack array % 146
dictstack/dstack exch % 146
 def % 146
} if % 146
 end % 146
 stop % 146
} bind % 146
 def % 146
/errorstop{//systemdict/errordict get % 146
 dup % 146
 2 % 136
 index % 146
 known % 146
{ exch % 146
 get % 146
 exec % 146
}{ pop % 146
//.erst exec % 146
} ifelse % 146
} bind % 146
 def % 146
/fix{{ exec % 146
} 0 % 136
 get % 146
 3 % 136
 array % 146
 dup % 146
 cvx % 146
executeonly 4 % 136
 1 % 136
 roll % 146
 astore % 146
 cvx % 146
readonly} bind % 146
 def % 146
/ingroups{ dup % 146
 1 % 136
 lt % 146
{/ingroups/rangecheck//errorstop exec % 146
}{ dup % 146
 1 % 136
 eq % 146
{ pop % 146
{ exec % 146
} 0 % 136
 get % 146
 3 % 136
 array % 146
 dup % 146
 cvx % 146
executeonly}{ 2 % 136
 sub % 146
 1 % 136
 array % 146
 3 % 136
 -1 % 136
 roll % 146
{ exec % 146
} 0 % 136
 get % 146
 2 % 136
 index % 146
 cvx % 146
executeonly 3 % 136
 array % 146
 astore % 146
 cvx % 146
readonly 3 % 136
 -1 % 136
 roll % 146
{ 1 % 136
 array % 146
 astore % 146
 cvx % 146
readonly} repeat % 146
} ifelse % 146
 exch % 146
 astore % 146
 cvx % 146
readonly} ifelse % 146
} bind % 146
 def % 146
/xforall{ exch % 146
 dup % 146
 type % 146
/dicttype eq % 146
{{ 3 % 136
 -1 % 136
 roll % 146
 exec % 146
}}{{ exch % 146
 exec % 146
}} ifelse % 146
 forall % 146
 pop % 146
} bind % 146
 def % 146
/export{ dup % 146
 length % 146
 dict % 146
 exch % 146
{ exch % 146
 1 % 136
 index % 146
 load % 146
 exch % 146
} forall % 146
 end % 146
 dup % 146
 begin % 146
 maxlength % 146
{ def % 146
} repeat % 146
 currentdict % 146
 end % 146
} bind % 146
 def % 146
/.escape{{ dup % 146
xcheck not % 146
{ //false % 141
 exit % 146
} if % 146
 dup % 146
 type % 146
/nametype eq % 146
 not % 146
{ //false % 141
 exit % 146
} if % 146
 dup % 146
/-| eq % 146
{ pop % 146
 0 % 136
 //true % 141
 exit % 146
} if % 146
 dup % 146
 dup % 146
 length % 146
 string % 146
 cvs % 146
 dup % 146
 0 % 136
 1 % 136
 getinterval % 146
//.hy eq % 146
 not % 146
{ pop % 146
 //false % 141
 exit % 146
} if % 146
 dup % 146
 dup % 146
 length % 146
 1 % 136
 sub % 146
 1 % 136
 getinterval % 146
//.vb eq % 146
 not % 146
{ pop % 146
 //false % 141
 exit % 146
} if % 146
 dup % 146
 dup % 146
 length % 146
 2 % 136
 sub % 146
 1 % 136
 exch % 146
 getinterval % 146
{ cvi % 146
} stopped % 146
{ pop % 146
 pop % 146
 //false % 141
 exit % 146
} if % 146
 exch % 146
 pop % 146
 exch % 146
 pop % 146
 //true % 141
 exit % 146
} loop % 146
} bind % 146
 def % 146
/hide+k{ exch % 146
 dup % 146
 5 % 136
 add % 146
 array % 146
{ stopped % 146
} 0 % 136
 get % 146
 1 % 136
 index % 146
 0 % 136
 5 % 136
 -1 % 136
 roll % 146
 getinterval % 146
 4 % 136
 2 % 136
 roll % 146
{ exec % 146
} 0 % 136
 get % 146
 exch % 146
 astore % 146
 dup % 146
 length % 146
 5 % 136
 sub % 146
 5 % 136
 getinterval % 146
 cvx % 146
executeonly exec % 146
} bind % 146
 def % 146
/.esiaph{ exch % 146
{ stop % 146
} if % 146
 aload % 146
 pop % 146
//hide+k exec % 146
} bind % 146
 def % 146
/.esiap//.esiaph 0 % 136
 5 % 136
 getinterval % 146
 def % 146
/.esi//.esiap 0 % 136
 3 % 136
 getinterval % 146
 def % 146
/hide{//.esi//hide+k exec % 146
} bind % 146
 def % 146
/hide+ap{//.esiap//hide+k exec % 146
} bind % 146
 def % 146
/hvhide+k{ 4 % 136
 -1 % 136
 roll % 146
 exch % 146
 3 % 136
 index % 146
 3 % 136
 index % 146
 sub % 146
 exch % 146
{ roll % 146
} 3 % 136
//.esiaph//hide+k exec % 146
} bind % 146
 def % 146
/hvhide{//.esi//hvhide+k exec % 146
} bind % 146
 def % 146
/hvhide+ap{//.esiap//hvhide+k exec % 146
} bind % 146
 def % 146
/.proc{ currentpacking{ packedarray}{ array % 146
 astore % 146
} ifelse % 146
} bind % 146
 def % 146
/.snarf{{ aload % 146
 length % 146
} exch % 146
//hide exec % 146
 aload % 146
 length % 146
 dup % 146
 2 % 136
 add % 146
 -1 % 136
 roll % 146
 add % 146
//.proc exec % 146
 cvx % 146
} bind % 146
 def % 146
/.if{{ 3 % 136
{ ifelse % 146
}}{ 2 % 136
{ if % 146
}} ifelse % 146
 0 % 136
 get % 146
 exch % 146
//.snarf exec % 146
} bind % 146
 def % 146
/if:{//.if} def % 146
/else:if{{//.if exec % 146
 //true % 141
 5 % 136
 -1 % 136
 roll % 146
 exec % 146
}} bind % 146
 def % 146
/else:{{{ errordict/typecheck get % 146
 exec % 146
} if % 146
 exch % 146
 5 % 136
 -1 % 136
 roll % 146
 exec % 146
} //true % 141
} bind % 146
 def % 146
/:if{ //false % 141
 4 % 136
 -1 % 136
 roll % 146
 exec % 146
} bind % 146
 def % 146
/:and{{{ //false % 141
} ifelse % 146
} aload % 146
 pop % 146
 3 % 136
//.snarf exec % 146
} bind % 146
 def % 146
/:or{{ //true % 141
} exch % 146
{ ifelse % 146
} 0 % 136
 get % 146
 3 % 136
//.snarf exec % 146
} bind % 146
 def % 146
/enq{ exch % 146
 0 % 136
 2 % 136
 copy % 146
 get % 146
 dup % 146
 null % 146
 eq % 146
{ pop % 146
 2 % 136
 index % 146
 put % 146
 dup % 146
}{ dup % 146
 length % 146
 1 % 136
 sub % 146
 2 % 136
 copy % 146
 get % 146
 6 % 136
 1 % 136
 roll % 146
 4 % 136
 index % 146
 put % 146
 2 % 136
 index % 146
 put % 146
} ifelse % 146
} bind % 146
 def % 146
/deq{ dup % 146
 0 % 136
 get % 146
 dup % 146
 null % 146
 eq % 146
{ pop % 146
 pop % 146
 //false % 141
}{ dup % 146
 length % 146
 1 % 136
 sub % 146
 2 % 136
 copy % 146
 get % 146
 4 % 136
 -1 % 136
 roll % 146
 1 % 136
 index % 146
 4 % 136
 index % 146
 eq % 146
{ 0 % 136
 null % 146
 put % 146
}{ pop % 146
} ifelse % 146
 dup % 146
 length % 146
 1 % 136
 sub % 146
 2 % 136
 copy % 146
 0 % 136
 exch % 146
 getinterval % 146
 5 % 136
 1 % 136
 roll % 146
 get % 146
 put % 146
 //true % 141
} ifelse % 146
} bind % 146
 def % 146
/.inidict [ <</lvl 0 % 136
/out null % 146
/src null % 146
/beg 0 % 136
/at //false % 141
/above //false % 141
/splicing //false % 141
/recurs //false % 141
/lst null % 146
/len 0 % 136
/bal 0 % 136
>>{ dup % 146
 maxlength % 146
 dict % 146
 copy % 146
 begin % 146
/lst 1 % 136
 array % 146
 store % 146
} bind % 146
 aload % 146
 pop % 146
] cvx % 146
 def % 146
/.accum{ dup % 146
 length % 146
len add % 146
/len exch % 146
 store % 146
lst 2 % 136
 array % 146
//enq exec % 146
 astore % 146
 pop % 146
} bind % 146
 def % 146
/.dump{ lst//deq exec % 146
{ 0 % 136
 get % 146
 dup % 146
/src load % 146
 eq % 146
{lst 0 % 136
 get % 146
 null % 146
 eq % 146
}{ //false % 141
} ifelse % 146
{ //false % 141
}{recurs{ null % 146
/metapre-recursionundefined errorstop} if % 146
 aload % 146
 pop % 146
{lst//deq exec % 146
 not % 146
{ exit % 146
} if % 146
 0 % 136
 get % 146
 aload % 146
 pop % 146
} loop % 146
 //true % 141
} ifelse % 146
}{{} //false % 141
} ifelse % 146
{len//.proc exec % 146
} if % 146
} bind % 146
 def % 146
/.snip{/src load % 146
beg 2 % 136
 index % 146
 1 % 136
 index % 146
 sub % 146
 getinterval % 146
//.accum exec % 146
 dup % 146
 1 % 136
 add % 146
/beg exch % 146
 def % 146
} bind % 146
 def % 146
/.mark{ lvl exch % 146
 sub % 146
 currentdict % 146
{ dup % 146
 dup % 146
 null % 146
 eq % 146
{ exit % 146
} if % 146
 dup % 146
/lvl get % 146
 3 % 136
 index % 146
 2 % 136
 copy % 146
 lt % 146
{ pop % 146
 pop % 146
 exit % 146
} if % 146
 eq % 146
{/at}{/above} ifelse % 146
 //true % 141
 put % 146
/out get % 146
} loop % 146
 pop % 146
 pop % 146
 pop % 146
} bind % 146
 def % 146
/.recursive{ currentdict % 146
{ dup % 146
/src get % 146
 2 % 136
 index % 146
 eq % 146
{/recurs //true % 141
 put % 146
 //true % 141
 exit % 146
} if % 146
/out get % 146
 dup % 146
 null % 146
 eq % 146
{ pop % 146
 //false % 141
 exit % 146
} if % 146
} loop % 146
} bind % 146
 def % 146
/.metapre currentpacking //false % 141
setpacking{{} exec % 146
} bind % 146
 exch % 146
setpacking def % 146
/.metaprex//.metapre executeonly def % 146
/metabind{ bind % 146
//.inidict exec % 146
//.metapre exec % 146
 end % 146
 cvx % 146
} bind % 146
 def % 146
/metapre//metabind dup % 146
 length % 146
 1 % 136
 sub % 146
 1 % 136
 exch % 146
 getinterval % 146
 def % 146
/x.metapre//metapre executeonly def % 146
/.delims <</-|{/-| cvx % 146
}/|-{/|- cvx % 146
}>> readonly def % 146
/.cases if:{ splicing} if:{ dup % 146
xcheck}{ dup % 146
 type % 146
/nametype eq % 146
}:and if:{ dup % 146
/-| eq % 146
}{ pop % 146
/bal bal 1 % 136
 add % 146
 store % 146
}else:if{/|- eq % 146
}if:{ bal 0 % 136
 gt % 146
}{/bal bal 1 % 136
 sub % 146
 store % 146
}else:{/src load % 146
beg 2 % 136
 index % 146
 1 % 136
 index % 146
 sub % 146
 getinterval % 146
 cvx % 146
 1 % 136
 index % 146
 1 % 136
 add % 146
/beg exch % 146
 def % 146
/splicing //false % 141
 def % 146
 currentdict % 146
 end % 146
 exch % 146
 currentdict % 146
//.delims begin % 146
 begin % 146
 2 % 136
//hide exec % 146
 end % 146
 end % 146
 aload % 146
 pop % 146
//.inidict exec % 146
//.metaprex 2 % 136
//hide exec % 146
 end % 146
 aload % 146
 pop % 146
 begin % 146
 exch % 146
//.accum exec % 146
}:if :if else:{ pop % 146
}:if else:if{ dup % 146
xcheck not % 146
}{ pop % 146
}else:if{ dup % 146
 type % 146
 dup % 146
/arraytype eq % 146
 exch % 146
/packedarraytype eq % 146
 or % 146
}if:{ dup % 146
rcheck not % 146
}{ pop % 146
}else:if{//.recursive exec % 146
}{ pop % 146
}else:{ exch % 146
 1 % 136
 index % 146
/out currentdict % 146
/lvl lvl 1 % 136
 add % 146
 end % 146
//.inidict exec % 146
 def % 146
 def % 146
//.metaprex 2 % 136
//hide exec % 146
 aload % 146
 pop % 146
 2 % 136
 index % 146
 ne % 146
at or % 146
{ exch % 146
at above not % 146
 and % 146
{ cvlit % 146
//x.metapre{ exec % 146
} 0 % 136
 get % 146
 3 % 136
}{ cvx % 146
 1 % 136
} ifelse % 146
 array % 146
 astore % 146
out end % 146
 begin % 146
 exch % 146
//.snip exec % 146
 exch % 146
//.accum exec % 146
}{ exch % 146
 pop % 146
out end % 146
 begin % 146
} ifelse % 146
}:if else:if{//.escape exec % 146
}if:{ dup % 146
lvl eq % 146
}{ pop % 146
//.snip exec % 146
/splicing //true % 141
 def % 146
}else:{//.mark exec % 146
}:if else:{ pop % 146
}:if bind % 146
 def % 146
/.metapre load % 146
 0 % 136
{/src exch % 146
 def % 146
/beg 0 % 136
 def % 146
 0 % 136
/src load % 146
{//.cases exec % 146
 1 % 136
 add % 146
} forall % 146
/src load % 146
 exch % 146
beg exch % 146
 1 % 136
 index % 146
 sub % 146
 getinterval % 146
//.accum exec % 146
//.dump exec % 146
} bind % 146
 put % 146
 setglobal % 146
setpacking{/errorstop/export/enq/deq/fix/ingroups/xforall/hide+k/hide/hide+ap/hvhide+k/hvhide/hvhide+ap/if:/else:if/else:/:if/:and/:or/metapre/metabind} export/net.anastigmatix.MetaPre exch % 146
/ProcSet defineresource pop % 146
