/net.anastigmatix.Order/ProcSet resourcestatus{ pop % 146
 2 % 136
 lt % 146
{ currentfile % 146
 flushfile % 146
} if % 146
} if % 146
 42 % 136
 dict % 146
 begin % 146
 currentpacking //false % 141
 setpacking currentglobal % 146
 //true % 141
 setglobal % 146
/PolyCmp{ 2 % 136
 copy % 146
 lt % 146
{ pop % 146
 pop % 146
 -1 % 136
}{ eq % 146
{ 0 % 136
}{ 1 % 136
} ifelse % 146
} ifelse % 146
} bind % 146
 def % 146
/BinarySearch{{ 1 % 136
 sub % 146
 exch % 146
 pop % 146
}{ exch % 146
 pop % 146
 exch % 146
 pop % 146
 //true % 141
 exit % 146
}{ 3 % 136
 -1 % 136
 roll % 146
 pop % 146
 1 % 136
 add % 146
 exch % 146
} 0 % 136
 6 % 136
 index % 146
 length % 146
 1 % 136
 sub % 146
{ 2 % 136
 copy % 146
 gt % 146
{ pop % 146
 //false % 141
 exit % 146
} if % 146
 2 % 136
 copy % 146
 add % 146
 -1 % 136
 bitshift % 146
 8 % 136
 index % 146
 1 % 136
 index % 146
 get % 146
 8 % 136
 index % 146
 8 % 136
 index % 146
 exec % 146
 4 % 136
 add % 146
 index % 146
 exec % 146
} loop % 146
 8 % 136
 2 % 136
 roll % 146
 pop % 146
 pop % 146
 pop % 146
 pop % 146
 pop % 146
 pop % 146
} bind % 146
 def % 146
/InsSortStk{ 4 % 136
 1 % 136
 3 % 136
 index % 146
 2 % 136
 add % 146
{ dup % 146
 index % 146
 5 % 136
 1 % 136
 3 % 136
 index % 146
 1 % 136
 add % 146
{ dup % 146
 index % 146
 2 % 136
 index % 146
 5 % 136
 index % 146
 exec % 146
 0 % 136
 lt % 146
{ 1 % 136
 sub % 146
 1 % 136
 roll % 146
 1 % 136
 add % 146
 -1 % 136
 roll % 146
 0 % 136
 exit % 146
}{ pop % 146
} ifelse % 146
} for % 146
 pop % 146
 pop % 146
} for % 146
 pop % 146
} bind % 146
 def % 146
/InsSortStack{ exch % 146
//InsSortStk exec % 146
} bind % 146
 def % 146
/InsStk{ //true % 141
 5 % 136
 1 % 136
 5 % 136
 index % 146
 4 % 136
 add % 146
{ dup % 146
 index % 146
 3 % 136
 index % 146
 5 % 136
 index % 146
 exec % 146
 1 % 136
 eq % 146
{ pop % 146
}{ exch % 146
 pop % 146
 2 % 136
 sub % 146
 1 % 136
 roll % 146
 //false % 141
 exit % 146
} ifelse % 146
} for % 146
{ 2 % 136
 index % 146
 3 % 136
 add % 146
 1 % 136
 roll % 146
} if % 146
 exch % 146
 1 % 136
 add % 146
 exch % 146
} bind % 146
 def % 146
/sload{ dup % 146
{ exch % 146
} forall % 146
} bind % 146
 def % 146
/sstore{ dup % 146
 dup % 146
 length % 146
 1 % 136
 sub % 146
 -1 % 136
 0 % 136
{ 4 % 136
 -1 % 136
 roll % 146
 put % 146
 dup % 146
} for % 146
 pop % 146
} bind % 146
 def % 146
/InsSort{ 0 % 136
 exch % 146
 2 % 136
 index % 146
//InsStk forall % 146
 pop % 146
 index % 146
 dup % 146
 type % 146
/stringtype eq % 146
{//sstore exec % 146
 pop % 146
}{ astore % 146
 pop % 146
} ifelse % 146
} bind % 146
 def % 146
/MinMax{{{ 2 % 136
 copy % 146
 7 % 136
 index % 146
 exec % 146
{ 2 % 136
 index % 146
 1 % 136
 index % 146
 7 % 136
 index % 146
 exec % 146
{ 3 % 136
 1 % 136
 roll % 146
 exch % 146
} if % 146
 pop % 146
}{ 2 % 136
 index % 146
 2 % 136
 index % 146
 7 % 136
 index % 146
 exec % 146
{ 3 % 136
 -1 % 136
 roll % 146
 pop % 146
}{ exch % 146
 pop % 146
} ifelse % 146
} ifelse % 146
 dup % 146
 3 % 136
 index % 146
 6 % 136
 index % 146
 exec % 146
{ 3 % 136
 1 % 136
 roll % 146
 exch % 146
} if % 146
 pop % 146
 2 % 136
 index % 146
}} 2 % 136
 index % 146
 length % 146
 1 % 136
 and % 146
 0 % 136
 eq % 146
{ 2 % 136
 index % 146
 length % 146
 0 % 136
 eq % 146
{ pop % 146
/MinMax errordict/rangecheck get % 146
 exec % 146
} if % 146
{{ 2 % 136
 copy % 146
 5 % 136
 index % 146
 exec % 146
{ 2 % 136
 index % 146
}{ exch % 146
 2 % 136
 index % 146
} ifelse % 146
}}}{{ dup % 146
 2 % 136
 index % 146
}} ifelse % 146
 4 % 136
 -1 % 136
 roll % 146
{ exch % 146
 exec % 146
} forall % 146
 pop % 146
 4 % 136
 2 % 136
 roll % 146
 pop % 146
 pop % 146
} bind % 146
 def % 146
/MinMaxCmp{{{ 2 % 136
 copy % 146
 7 % 136
 index % 146
 exec % 146
 0 % 136
 lt % 146
{ 2 % 136
 index % 146
 1 % 136
 index % 146
 7 % 136
 index % 146
 exec % 146
 0 % 136
 lt % 146
{ 3 % 136
 1 % 136
 roll % 146
 exch % 146
} if % 146
 pop % 146
}{ 2 % 136
 index % 146
 2 % 136
 index % 146
 7 % 136
 index % 146
 exec % 146
 0 % 136
 lt % 146
{ 3 % 136
 -1 % 136
 roll % 146
 pop % 146
}{ exch % 146
 pop % 146
} ifelse % 146
} ifelse % 146
 dup % 146
 3 % 136
 index % 146
 6 % 136
 index % 146
 exec % 146
 0 % 136
 lt % 146
{ 3 % 136
 1 % 136
 roll % 146
 exch % 146
} if % 146
 pop % 146
 2 % 136
 index % 146
}} 2 % 136
 index % 146
 length % 146
 1 % 136
 and % 146
 0 % 136
 eq % 146
{ 2 % 136
 index % 146
 length % 146
 0 % 136
 eq % 146
{ pop % 146
/MinMaxCmp errordict/rangecheck get % 146
 exec % 146
} if % 146
{{ 2 % 136
 copy % 146
 5 % 136
 index % 146
 exec % 146
 0 % 136
 lt % 146
{ 2 % 136
 index % 146
}{ exch % 146
 2 % 136
 index % 146
} ifelse % 146
}}}{{ dup % 146
 2 % 136
 index % 146
}} ifelse % 146
 4 % 136
 -1 % 136
 roll % 146
{ exch % 146
 exec % 146
} forall % 146
 pop % 146
 4 % 136
 2 % 136
 roll % 146
 pop % 146
 pop % 146
} bind % 146
 def % 146
/FindMin{ 1 % 136
 index % 146
 length % 146
 0 % 136
 eq % 146
{/FindMin errordict/rangecheck get % 146
 exec % 146
} if % 146
 0 % 136
 2 % 136
 index % 146
 0 % 136
 get % 146
 1 % 136
 1 % 136
 5 % 136
 index % 146
 length % 146
 1 % 136
 sub % 146
{ 4 % 136
 index % 146
 1 % 136
 index % 146
 get % 146
 dup % 146
 3 % 136
 index % 146
 6 % 136
 index % 146
 exec % 146
 0 % 136
 lt % 146
{ 4 % 136
 2 % 136
 roll % 146
} if % 146
 pop % 146
 pop % 146
} for % 146
 4 % 136
 2 % 136
 roll % 146
 pop % 146
 pop % 146
} bind % 146
 def % 146
/FindMax{ 1 % 136
 index % 146
 length % 146
 0 % 136
 eq % 146
{/FindMin errordict/rangecheck get % 146
 exec % 146
} if % 146
 0 % 136
 2 % 136
 index % 146
 0 % 136
 get % 146
 1 % 136
 1 % 136
 5 % 136
 index % 146
 length % 146
 1 % 136
 sub % 146
{ 4 % 136
 index % 146
 1 % 136
 index % 146
 get % 146
 dup % 146
 3 % 136
 index % 146
 6 % 136
 index % 146
 exec % 146
 0 % 136
 gt % 146
{ 4 % 136
 2 % 136
 roll % 146
} if % 146
 pop % 146
 pop % 146
} for % 146
 4 % 136
 2 % 136
 roll % 146
 pop % 146
 pop % 146
} bind % 146
 def % 146
/Trichotomize{ 2 % 136
 index % 146
 1 % 136
 index % 146
 1 % 136
 index % 146
 length % 146
 1 % 136
 index % 146
 sub % 146
 getinterval % 146
 4 % 136
 copy % 146
 pop % 146
 1 % 136
 index % 146
 sub % 146
 getinterval % 146
 5 % 136
 2 % 136
 roll % 146
 pop % 146
 0 % 136
 exch % 146
 getinterval % 146
} bind % 146
 def % 146
/swap{ 2 % 136
 index % 146
 exch % 146
 4 % 136
 copy % 146
 get % 146
 5 % 136
 1 % 136
 roll % 146
 get % 146
 put % 146
 put % 146
} bind % 146
 def % 146
/.p0{ 10 % 136
 index % 146
 2 % 136
 index % 146
 2 % 136
 index % 146
//swap exec % 146
} bind % 146
 def % 146
/Partition{{}{{} exit % 146
}{//.p0 exit % 146
}{ exch % 146
 pop % 146
//.p0 exit % 146
}{ exch % 146
 exit % 146
}{} -1 % 136
 9 % 136
 index % 146
 length % 146
{{ 1 % 136
 sub % 146
 10 % 136
 index % 146
 1 % 136
 index % 146
 get % 146
 10 % 136
 index % 146
 10 % 136
 index % 146
 exec % 146
 6 % 136
 add % 146
 index % 146
 exec % 146
} loop % 146
 3 % 136
 -1 % 136
 roll % 146
{ 1 % 136
 add % 146
 11 % 136
 index % 146
 1 % 136
 index % 146
 get % 146
 11 % 136
 index % 146
 11 % 136
 index % 146
 exec % 146
 4 % 136
 add % 146
 index % 146
 exec % 146
} loop % 146
 2 % 136
 index % 146
 2 % 136
 index % 146
 gt % 146
 exch % 146
{ exch % 146
 exit % 146
} ifelse % 146
 exch % 146
} loop % 146
 10 % 136
 2 % 136
 roll % 146
 8 % 136
{ pop % 146
} repeat % 146
 1 % 136
 add % 146
//Trichotomize exec % 146
} bind % 146
 def % 146
 //true % 141
 setpacking/.s0{ 3 % 136
 index % 146
 length % 146
 16 % 136
 le % 146
{ pop % 146
 exch % 146
 pop % 146
//InsSort exec % 146
 pop % 146
}{ 4 % 136
 -1 % 136
 roll % 146
 dup % 146
 0 % 136
 get % 146
 1 % 136
 4 % 136
 index % 146
 3 % 136
 index % 146
 dup % 146
 length % 146
 1 % 136
 sub % 146
 get % 146
//InsStk exec % 146
 4 % 136
 index % 146
 dup % 146
 length % 146
 2 % 136
 idiv % 146
 get % 146
//InsStk exec % 146
 pop % 146
 pop % 146
 pop % 146
 exch % 146
 pop % 146
 3 % 136
 index % 146
//Partition exec % 146
 6 % 136
 -1 % 136
 roll % 146
 1 % 136
 index % 146
 length % 146
 2 % 136
 copy % 146
 lt % 146
{ pop % 146
 6 % 136
 2 % 136
 roll % 146
 pop % 146
 pop % 146
 dup % 146
 exec % 146
}{ sub % 146
 exch % 146
 pop % 146
 1 % 136
 index % 146
 length % 146
 2 % 136
 copy % 146
 lt % 146
{ pop % 146
 pop % 146
 pop % 146
 pop % 146
 pop % 146
 pop % 146
}{ sub % 146
 exch % 146
 pop % 146
 4 % 136
 2 % 136
 roll % 146
 dup % 146
 exec % 146
} ifelse % 146
} ifelse % 146
} ifelse % 146
} bind % 146
 def % 146
/.s1{ 2 % 136
 index % 146
 0 % 136
 eq % 146
{ pop % 146
 2 % 136
 index % 146
 exch % 146
//FindMin exec % 146
 pop % 146
//swap exec % 146
}{ 2 % 136
 index % 146
 4 % 136
 index % 146
 length % 146
 1 % 136
 sub % 146
 ne % 146
//.s0{ pop % 146
 2 % 136
 index % 146
 exch % 146
//FindMax exec % 146
 pop % 146
//swap exec % 146
} ifelse % 146
} ifelse % 146
} bind % 146
 def % 146
/Select{{/Select errordict/rangecheck get % 146
 exec % 146
} 2 % 136
 index % 146
 0 % 136
 le % 146
{ exec % 146
} if % 146
 3 % 136
 index % 146
 length % 146
 3 % 136
 index % 146
 lt % 146
{ exec % 146
} if % 146
 pop % 146
 exch % 146
 1 % 136
 sub % 146
 exch % 146
 2 % 136
 index % 146
 exch % 146
 2 % 136
 index % 146
 exch % 146
//.s1 dup % 146
 exec % 146
 dup % 146
 1 % 136
 add % 146
//Trichotomize exec % 146
} bind % 146
 def % 146
/SelectOrd{ pop % 146
 dup % 146
 1 % 136
 sub % 146
 exch % 146
//Trichotomize exec % 146
} bind % 146
 def % 146
/.o0{ dup % 146
 length % 146
 -1 % 136
 bitshift % 146
 dup % 146
 1 % 136
 add % 146
//Trichotomize exec % 146
 exch % 146
 4 % 136
 -1 % 136
 roll % 146
 1 % 136
 index % 146
 0 % 136
 get % 146
 7 % 136
 index % 146
 7 % 136
 index % 146
 exec % 146
 exch % 146
 0 % 136
 get % 146
 4 % 136
 -1 % 136
 roll % 146
 exch % 146
 0 % 136
 exch % 146
 put % 146
 3 % 136
 -1 % 136
 roll % 146
 7 % 136
 2 % 136
 roll % 146
 exch % 146
 6 % 136
 index % 146
 length % 146
 1 % 136
 add % 146
 neg % 146
 dup % 146
 2 % 136
 index % 146
{ add % 146
 3 % 136
 1 % 136
 roll % 146
 dup % 146
} forall % 146
 pop % 146
 pop % 146
 dup % 146
 type % 146
/stringtype eq % 146
{//sstore exec % 146
}{ astore % 146
} ifelse % 146
 2 % 136
 index % 146
 exec % 146
 5 % 136
 -2 % 136
 roll % 146
 2 % 136
 index % 146
 exec % 146
} bind % 146
 def % 146
/.o1{ dup % 146
 length % 146
 dup % 146
 2 % 136
 gt % 146
{ pop % 146
//.o0 exec % 146
}{ dup % 146
 0 % 136
 eq % 146
{ pop % 146
 pop % 146
 pop % 146
}{ 2 % 136
 ne % 146
//.o0{ dup % 146
 0 % 136
 get % 146
 1 % 136
 ne % 146
//.o0{ dup % 146
 1 % 136
 get % 146
 2 % 136
 index % 146
 length % 146
 ne % 146
//.o0{ exch % 146
 4 % 136
 index % 146
//MinMaxCmp exec % 146
 3 % 136
 -1 % 136
 roll % 146
 dup % 146
 type % 146
/stringtype eq % 146
{//sstore exec % 146
}{ astore % 146
} ifelse % 146
 pop % 146
} ifelse % 146
} ifelse % 146
} ifelse % 146
} ifelse % 146
} ifelse % 146
} bind % 146
 def % 146
/OrderStatistics{//.o1 5 % 136
 3 % 136
 roll % 146
 dup % 146
 6 % 136
 1 % 136
 roll % 146
 2 % 136
 index % 146
 exec % 146
 pop % 146
 pop % 146
 pop % 146
} bind % 146
 def % 146
 //false % 141
 setpacking/.q0{ 2 % 136
 index % 146
 length % 146
 16 % 136
 le % 146
{ pop % 146
//InsSort exec % 146
 pop % 146
}{ 3 % 136
 -1 % 136
 roll % 146
 dup % 146
 0 % 136
 get % 146
 1 % 136
 4 % 136
 index % 146
 3 % 136
 index % 146
 dup % 146
 length % 146
 1 % 136
 sub % 146
 get % 146
//InsStk exec % 146
 4 % 136
 index % 146
 dup % 146
 length % 146
 2 % 136
 idiv % 146
 get % 146
//InsStk exec % 146
 pop % 146
 pop % 146
 pop % 146
 exch % 146
 pop % 146
 3 % 136
 index % 146
//Partition exec % 146
 exch % 146
 pop % 146
 1 % 136
 index % 146
 length % 146
 1 % 136
 index % 146
 length % 146
 lt % 146
{ exch % 146
} if % 146
 3 % 136
 index % 146
 3 % 136
 index % 146
 dup % 146
 exec % 146
 3 % 136
 1 % 136
 roll % 146
 dup % 146
 exec % 146
} ifelse % 146
} bind % 146
 def % 146
/QuickSort{ 1 % 136
 index % 146
 exch % 146
//.q0 dup % 146
 exec % 146
} bind % 146
 def % 146
/.h0{ dup % 146
 6 % 136
 index % 146
 ge % 146
{ pop % 146
}{ 7 % 136
 index % 146
 1 % 136
 index % 146
 get % 146
 dup % 146
 3 % 136
 index % 146
 9 % 136
 index % 146
 exec % 146
 0 % 136
 gt % 146
{ 4 % 136
 2 % 136
 roll % 146
} if % 146
 pop % 146
 pop % 146
} ifelse % 146
} bind % 146
 def % 146
/Heapify{{ 3 % 136
 index % 146
 1 % 136
 index % 146
 get % 146
 2 % 136
 copy % 146
 3 % 136
 index % 146
 1 % 136
 bitshift % 146
 1 % 136
 add % 146
//.h0 exec % 146
 3 % 136
 index % 146
 1 % 136
 add % 146
 1 % 136
 bitshift % 146
//.h0 exec % 146
 3 % 136
 index % 146
 2 % 136
 index % 146
 eq % 146
{ pop % 146
 pop % 146
 pop % 146
 pop % 146
 exit % 146
} if % 146
 6 % 136
 index % 146
 5 % 136
 -1 % 136
 roll % 146
 3 % 136
 -1 % 136
 roll % 146
 put % 146
 4 % 136
 index % 146
 1 % 136
 index % 146
 3 % 136
 index % 146
 put % 146
 exch % 146
 pop % 146
} loop % 146
} bind % 146
 def % 146
/BuildHeap{ 1 % 136
 index % 146
 length % 146
 dup % 146
 -1 % 136
 bitshift % 146
 1 % 136
 sub % 146
 -1 % 136
 0 % 136
//Heapify for % 146
} bind % 146
 def % 146
/HeapSort{ 1 % 136
 index % 146
 length % 146
 80 % 136
 le % 146
//QuickSort{//BuildHeap exec % 146
 dup % 146
 1 % 136
 sub % 146
 -1 % 136
 1 % 136
{ 3 % 136
 index % 146
 exch % 146
 0 % 136
//swap exec % 146
 1 % 136
 sub % 146
 0 % 136
//Heapify exec % 146
} for % 146
 pop % 146
 pop % 146
} ifelse % 146
} bind % 146
 def % 146
/Hist{ 1 % 136
 index % 146
 type % 146
/arraytype eq % 146
{ 1 % 136
 index % 146
 dup % 146
 4 % 136
 index % 146
 length % 146
 -1 % 136
 0 % 136
{ 2 % 136
 copy % 146
 get % 146
 type % 146
/integertype eq % 146
{ pop % 146
}{ 0 % 136
 put % 146
 dup % 146
} ifelse % 146
} for % 146
 pop % 146
 pop % 146
} if % 146
 1 % 136
 index % 146
 3 % 136
 index % 146
 5 % 136
 index % 146
{ 3 % 136
 index % 146
//BinarySearch exec % 146
 pop % 146
 2 % 136
 copy % 146
 get % 146
 1 % 136
 add % 146
 put % 146
 1 % 136
 index % 146
 3 % 136
 index % 146
} forall % 146
 pop % 146
 pop % 146
 pop % 146
 exch % 146
 pop % 146
 exch % 146
 pop % 146
} bind % 146
 def % 146
/.u0{ pop % 146
} bind % 146
 def % 146
/.u05{ index % 146
 2 % 136
 index % 146
 2 % 136
 index % 146
 put % 146
 exch % 146
 1 % 136
 add % 146
 exch % 146
} bind % 146
 def % 146
/.u1{ exch % 146
 pop % 146
 5 % 136
//.u05 exec % 146
} bind % 146
 def % 146
/.u2{//.u0//.u1} bind % 146
 def % 146
/.u0c{ pop % 146
 5 % 136
 index % 146
 2 % 136
 index % 146
 1 % 136
 sub % 146
 2 % 136
 copy % 146
 get % 146
 1 % 136
 add % 146
 put % 146
} bind % 146
 def % 146
/.u1c{ exch % 146
 pop % 146
 5 % 136
 index % 146
 2 % 136
 index % 146
 1 % 136
 put % 146
 6 % 136
//.u05 exec % 146
} bind % 146
 def % 146
/.u2c{//.u0c//.u1c} bind % 146
 def % 146
/.u3{ exch % 146
 1 % 136
 index % 146
 3 % 136
 index % 146
 8 % 136
 index % 146
 exec % 146
 1 % 136
 and % 146
 get % 146
 exec % 146
} bind % 146
 def % 146
/.u4{ index % 146
 2 % 136
 index % 146
 2 % 136
 index % 146
 put % 146
 exch % 146
 1 % 136
 add % 146
 exch % 146
} bind % 146
 def % 146
/.u5{ exch % 146
 exec % 146
 3 % 136
 index % 146
 3 % 136
 index % 146
} bind % 146
 def % 146
 //true % 141
 setpacking/.u6{ pop % 146
 pop % 146
 pop % 146
 exch % 146
 pop % 146
 exch % 146
 pop % 146
 exch % 146
 pop % 146
} bind % 146
 def % 146
/Uniq{ dup % 146
 xcheck{//.u2//.u3 0 % 136
 null % 146
//.u2{ exch % 146
 pop % 146
 exch % 146
 pop % 146
 5 % 136
//.u4 exec % 146
} 7 % 136
 index % 146
//.u5 forall % 146
//.u6 exec % 146
 0 % 136
 exch % 146
 getinterval % 146
}{ exch % 146
//.u2c//.u3 0 % 136
 null % 146
//.u2c{ exch % 146
 pop % 146
 exch % 146
 pop % 146
 5 % 136
 index % 146
 0 % 136
 1 % 136
 put % 146
 6 % 136
//.u4 exec % 146
} 8 % 136
 index % 146
//.u5 forall % 146
//.u6 exec % 146
 exch % 146
 0 % 136
 2 % 136
 index % 146
 getinterval % 146
 3 % 136
 1 % 136
 roll % 146
 0 % 136
 exch % 146
 getinterval % 146
 exch % 146
} ifelse % 146
} bind % 146
 def % 146
 setglobal % 146
 setpacking{/PolyCmp/MinMax/MinMaxCmp/FindMin/FindMax/InsSortStk/InsSortStack/InsStk/InsSort/Partition/QuickSort/Select/SelectOrd/OrderStatistics/Heapify/BuildHeap/HeapSort/Trichotomize/sload/sstore/swap/BinarySearch/Uniq/Hist} dup % 146
 length % 146
 dict % 146
 exch % 146
{ exch % 146
 1 % 136
 index % 146
 load % 146
 exch % 146
} forall % 146
 end % 146
 dup % 146
 begin % 146
 maxlength % 146
{ def % 146
} repeat % 146
 currentdict % 146
 end % 146
/net.anastigmatix.Order exch % 146
/ProcSet defineresource pop % 146
