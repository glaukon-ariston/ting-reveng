/net.anastigmatix.Packager/ProcSet resourcestatus{ pop % 146
 2 % 136
 lt % 146
{ currentfile % 146
 flushfile % 146
} if % 146
} if % 146
/net.anastigmatix.MetaPre/ProcSet findresource % 146
 begin % 146
/net.anastigmatix.StreamIO/ProcSet findresource % 146
 begin % 146
/net.anastigmatix.BinaryIO/ProcSet findresource % 146
 begin % 146
/net.anastigmatix.Markup/ProcSet findresource % 146
 begin % 146
currentpacking //true % 141
setpacking 98 % 136
 dict % 146
 begin % 146
/PackagerIdent (\n% net.anastigmatix.Packager 0.1 12\n) % 142
readonly def % 146
/RD_LEN 6 % 136
 def % 146
/OR_FOLQ 0 % 136
 def % 146
/OR_NPREQ 1 % 136
 def % 146
/RD_KEY 2 % 136
 def % 146
/RD_CAT 3 % 136
 def % 146
/RD_NQUAL 4 % 136
 def % 146
/RD_SQUAL 5 % 136
 def % 146
/dpm [6 0 0 6 0 0] % 149
readonly def % 146
/dscr (%!PS-Adobe-3.0 Resource-) % 142
readonly def % 146
/dsc+ (%%+) % 142
readonly def % 146
/dscnr (%%DocumentNeededResources:) % 142
readonly def % 146
/dscsr (%%DocumentSuppliedResources:) % 142
readonly def % 146
/dscir (%%IncludeResource:) % 142
readonly def % 146
/dscbr (%%BeginResource:) % 142
readonly def % 146
/cosp (: ) % 142
readonly def % 146
/ht (\t) % 142
readonly def % 146
/lf (\n) % 142
readonly def % 146
/sp ( ) % 142
readonly def % 146
/comv (,v) % 142
readonly def % 146
/dot (.) % 142
readonly def % 146
/lbrk ([) % 142
readonly def % 146
/rbrk (]) % 142
readonly def % 146
/slash (/) % 142
readonly def % 146
/lbrc ({) % 142
readonly def % 146
/rbrc (}) % 142
readonly def % 146
/wmsg (warning: this PostScript interpreter tests positive for a bug that affects\n         closing of filters. If output is incomplete, that could be the cause.\n         See www.anastigmatix.net/postscript/S...) % 142
readonly def % 146
/unwarned//filterCloseBug{ (\001) % 142
}{ (\000) % 142
} ifelse % 146
 def % 146
/bugwarn{//unwarned dup % 146
 0 % 136
 get % 146
 0 % 136
 ne % 146
{ 0 % 136
 0 % 136
 put % 146
//stderr exec % 146
 dup % 146
//wmsg writestring % 146
 flushfile % 146
}{ pop % 146
} ifelse % 146
} bind % 146
 def % 146
/mtgrd <</GenericResourceDir () % 142
>> readonly def % 146
/d2c 5 % 136
 dict % 146
 def % 146
/c2d 5 % 136
 dict % 146
 def % 146
d2c{{ c2d 1 % 136
 index % 146
 3 % 136
 index % 146
readonly put % 146
readonly put % 146
 2 % 136
 copy % 146
}} 2 % 136
 copy % 146
{ (encoding) % 142
 (Encoding) % 142
 (font) % 142
 (Font) % 142
 (form) % 142
 (Form) % 142
 (pattern) % 142
 (Pattern) % 142
 (procset) % 142
 (ProcSet) % 142
}{ exch % 146
 exec % 146
} forall % 146
 pop % 146
 pop % 146
 pop % 146
readonly pop % 146
c2d readonly pop % 146
/c0{ exch % 146
 2 % 136
 copy % 146
 known % 146
{ get % 146
}{ exch % 146
 pop % 146
 dup % 146
 type % 146
/stringtype ne % 146
{ dup % 146
 length % 146
 string % 146
 cvs % 146
} if % 146
} ifelse % 146
} bind % 146
 def % 146
/CategoryTo46Key{//c2d//c0 exec % 146
} bind % 146
 def % 146
/46KeyToCategory{//d2c//c0 exec % 146
} bind % 146
 def % 146
/write_int8{//write_int8} dup % 146
 0 % 136
 get % 146
 dup % 146
 type % 146
/operatortype ne % 146
{ exch % 146
} if % 146
 pop % 146
 def % 146
/bw{ out exch % 146
 write % 146
out 3 % 136
 1 % 136
 roll % 146
 exec % 146
/need-delim //false % 141
 store % 146
} bind % 146
 def % 146
/nwn{ need-delim{ out 32 % 136
 write % 146
}{/need-delim //true % 141
 store % 146
} ifelse % 146
out exch % 146
 writestring % 146
} bind % 146
 def % 146
/wn{ out exch % 146
 writestring % 146
/need-delim //true % 141
 store % 146
} bind % 146
 def % 146
/nw{ need-delim{ out 32 % 136
 write % 146
/need-delim //false % 141
 store % 146
} if % 146
out exch % 146
 writestring % 146
} bind % 146
 def % 146
/w{ out exch % 146
 writestring % 146
need-delim //false % 141
 store % 146
} bind % 146
 def % 146
/namecodes 226 % 134
 dict % 146
 (\221\000\210\000\222x) % 142
 cvx % 146
 dup % 146
 3 % 136
 copy % 146
 0 % 136
 1 % 136
 225 % 134
{ 2 % 136
 copy % 146
 1 % 136
 exch % 146
 put % 146
 3 % 136
 exch % 146
 put % 146
 stopped % 146
{ pop % 146
} if % 146
 3 % 136
 copy % 146
} for % 146
 5 % 136
{ pop % 146
} repeat % 146
readonly def % 146
/codedname{//namecodes exch % 146
 2 % 136
 copy % 146
 known % 146
{ dup % 146
xcheck{ get % 146
//write_int8 146 % 134
}{ get % 146
//write_int8 145 % 134
} ifelse % 146
//bw exec % 146
 //true % 141
}{ pop % 146
 pop % 146
 //false % 141
} ifelse % 146
} bind % 146
 def % 146
/w-boolean{{ 1 % 136
}{ 0 % 136
} ifelse % 146
//write_int8 141 % 134
//bw exec % 146
} bind % 146
 def % 146
/w-integer{ -| if:{ dup % 146
 127 % 136
 le % 146
}{ dup % 146
 -128 % 136
 ge % 146
}:and{//write_int8 136 % 134
}else:if{ dup % 146
 32767 % 134
 le % 146
}{ dup % 146
 -32768 % 134
 ge % 146
}:and{//writebe_int16 134 % 134
}else:{//writebe_int32 132 % 134
}:if |-//bw exec % 146
}metabind def % 146
/w-mark{ pop % 146
//lbrk//w exec % 146
} bind % 146
 def % 146
/w-name{ dup % 146
//codedname exec % 146
{ pop % 146
}{ dup % 146
 dup % 146
 length % 146
 string % 146
 cvs % 146
 exch % 146
xcheck{//nwn}{//slash//w exec % 146
//wn} ifelse % 146
 exec % 146
} ifelse % 146
} bind % 146
 def % 146
/w-real{//writebe_IEEE32 138 % 134
//bw exec % 146
} bind % 146
 def % 146
/w-string{ dup % 146
 length % 146
 dup % 146
 255 % 134
 le % 146
{//write_int8 142 % 134
}{//writebe_int16 143 % 134
} ifelse % 146
//bw exec % 146
//w exec % 146
} bind % 146
 def % 146
/homogeneous?{ //false % 141
{ type % 146
 3 % 136
 index % 146
 ne % 146
{ pop % 146
 pop % 146
 pop % 146
 //false % 141
 dup % 146
 dup % 146
 exit % 146
} if % 146
 dup % 146
}{ type % 146
 //true % 141
 4 % 136
 2 % 136
 roll % 146
 exch % 146
 pop % 146
 dup % 146
} 4 % 136
 -1 % 136
 roll % 146
{ exch % 146
 exec % 146
} forall % 146
 pop % 146
 pop % 146
} bind % 146
 def % 146
/.wla{//lbrk//w exec % 146
{dispatch} forall % 146
//rbrk//w exec % 146
} bind % 146
 def % 146
/w-larray{ dup % 146
//homogeneous? exec % 146
{ dup % 146
/integertype eq % 146
{ pop % 146
 //true % 141
 1 % 136
 index % 146
{ dup % 146
 -32768 % 134
 lt % 146
 exch % 146
 32767 % 134
 gt % 146
 or % 146
{ pop % 146
 //false % 141
} if % 146
} forall % 146
{ 32 % 136
//write_int8 149 % 134
//bw exec % 146
 dup % 146
 length % 146
out exch % 146
//writebe_int16 exec % 146
{out exch % 146
//writebe_int16 exec % 146
} forall % 146
}{ 0 % 136
//write_int8 149 % 134
//bw exec % 146
 dup % 146
 length % 146
out exch % 146
//writebe_int16 exec % 146
{out exch % 146
//writebe_int32 exec % 146
} forall % 146
} ifelse % 146
}{/realtype eq % 146
{ 48 % 136
//write_int8 149 % 134
//bw exec % 146
 dup % 146
 length % 146
out exch % 146
//writebe_int16 exec % 146
{out exch % 146
//writebe_IEEE32 exec % 146
} forall % 146
}//.wla ifelse % 146
} ifelse % 146
}//.wla ifelse % 146
} bind % 146
 def % 146
/w-xarray{//lbrc//w exec % 146
{dispatch} forall % 146
//rbrc//w exec % 146
} bind % 146
 def % 146
/w-array{ not % 146
{/net.anastigmatix.UndeclaredImmediate//errorstop exec % 146
} if % 146
 dup % 146
xcheck//w-xarray//w-larray ifelse % 146
} bind % 146
 def % 146
/dispatchmap <</booleantype//w-boolean/integertype//w-integer/marktype//w-mark/nametype//w-name/realtype//w-real/stringtype//w-string/arraytype{ dup % 146
wcheck//w-array exec % 146
} bind % 146
/packedarraytype{ dup % 146
rcheck//w-array exec % 146
} bind % 146
>> readonly def % 146
/dispatch{//dispatchmap 1 % 136
 index % 146
 type % 146
 2 % 136
 copy % 146
 known % 146
{ get % 146
 exec % 146
}{/net.anastigmatix.UnsupportedType//errorstop exec % 146
} ifelse % 146
} bind % 146
 def % 146
/tokenwriter{ 3 % 136
 dict % 146
 begin % 146
/out exch % 146
 def % 146
/dispatch//dispatch def % 146
/need-delim //false % 141
 def % 146
 currentdict % 146
 end % 146
{-| [ exch % 146
] |- begin % 146
//dispatch stopped % 146
{ end % 146
 stop % 146
} if % 146
 end % 146
}}metabind def % 146
/atload{ dup % 146
 length % 146
 dict % 146
 dup % 146
 3 % 136
 -1 % 136
 roll % 146
{ cvlit % 146
 dup % 146
 length % 146
 1 % 136
 add % 146
 string % 146
 dup % 146
 0 % 136
 47 % 136
 put % 146
 2 % 136
 copy % 146
 1 % 136
 2 % 136
 index % 146
 length % 146
 getinterval % 146
 cvs % 146
 pop % 146
 cvn % 146
 cvlit % 146
 put % 146
 dup % 146
} forall % 146
 pop % 146
readonly} bind % 146
 def % 146
/copytokens{ exch % 146
{ 3 % 136
 copy % 146
 begin % 146
{ token % 146
} stopped % 146
{ end % 146
 stop % 146
} if % 146
 end % 146
 not % 146
{ exit % 146
} if % 146
 exch % 146
 exec % 146
} loop % 146
 pop % 146
 pop % 146
 pop % 146
 pop % 146
} bind % 146
 def % 146
/cpath{//Basic exec % 146
 begin % 146
/PartLine{ dup % 146
 length % 146
 string % 146
 copy % 146
{ //true % 141
 charpath % 146
}-| [/Track load % 146
] |- exec % 146
} def % 146
/FullLine{ -| [/PartLine load % 146
] |- exec % 146
-| [ currentdict % 146
] |-/After get % 146
-| [ currentdict % 146
] |-/Before get % 146
-| [/Place load % 146
] |- exec % 146
}/BareLine 1 % 136
 index % 146
 def % 146
 def % 146
ResultHandlers dup % 146
/stringtype/PartLine load % 146
 put % 146
/nametype undef % 146
 currentdict % 146
 end % 146
}metabind def % 146
/pathprep{ true upath % 146
 flattenpath % 146
 pathbbox % 146
 newpath % 146
 4 % 136
 dict % 146
 begin % 146
 1 % 136
 0 % 136
 0 % 136
 -1 % 136
 5 % 136
 index % 146
 8 % 136
 index % 146
 sub % 146
 dup % 146
 ceiling % 146
/Width 1 % 136
 index % 146
 cvi % 146
 def % 146
 exch % 146
 sub % 146
 2 % 136
 div % 146
 8 % 136
 index % 146
 add % 146
 neg % 146
 5 % 136
 index % 146
 8 % 136
 index % 146
 sub % 146
 dup % 146
 ceiling % 146
/Height 1 % 136
 index % 146
 cvi % 146
 def % 146
 exch % 146
 sub % 146
 2 % 136
 div % 146
 6 % 136
 index % 146
 add % 146
 matrix % 146
 astore % 146
/ImageMatrix exch % 146
 def % 146
 pop % 146
 pop % 146
 pop % 146
 pop % 146
/PathMatrix//dpm def % 146
 currentdict % 146
 end % 146
} bind % 146
 def % 146
/wmdict{ dup % 146
 begin % 146
/Width dup % 146
 load % 146
/Height dup % 146
 load % 146
 3 % 136
 dict % 146
 begin % 146
 def % 146
 def % 146
 currentdict % 146
 end % 146
 end % 146
 begin % 146
/InUPathDecode//extfilter exec % 146
/DataSource exch % 146
 def % 146
 currentdict % 146
 end % 146
} bind % 146
 def % 146
/text{ <</PartLine{ -| [ 3 % 136
 index % 146
] |- exch % 146
 writestring % 146
}/HandleResult{ dup % 146
 type % 146
/stringtype eq % 146
-| [ 2 % 136
 index % 146
] |-{ dup % 146
xcheck{ -2| [ 5 % 136
 index % 146
] |- exch % 146
 exec % 146
} if % 146
} ifelse % 146
}/FullLine{ -| 3 % 136
 index % 146
 dup % 146
[ exch % 146
] |- exec % 146
//lf -| [ exch % 146
] |- exec % 146
}/BareLine 1 % 136
 index % 146
/LineBuffer 255 % 134
 string % 146
/HandleToken{ exec % 146
}>> exch % 146
 pop % 146
}metabind def % 146
/stackf{ exch % 146
 4 % 136
 index % 146
 exch % 146
 dup % 146
xcheck{ exec % 146
}{ writestring % 146
} ifelse % 146
 3 % 136
 index % 146
 exch % 146
 5 % 136
 2 % 136
 roll % 146
//extfilter exec % 146
 1 % 136
 index % 146
xcheck{{ -| [ 4 % 136
 2 % 136
 roll % 146
 1 % 136
 array % 146
 astore % 146
 cvx % 146
] |- 0 % 136
 get % 146
 exec % 146
}}{{-| [ 4 % 136
 2 % 136
 roll % 146
] |- writestring % 146
}} ifelse % 146
{-| [ 2 % 136
 index % 146
] |- closefile//bugwarn exec % 146
-| [ exch % 146
] |- exec % 146
-| [ 3 % 136
 -1 % 136
 roll % 146
 1 % 136
 array % 146
 astore % 146
 cvx % 146
] |- 0 % 136
 get % 146
 exec % 146
} exch % 146
}metabind def % 146
/fstack{{{ -| [ 2 % 136
 index % 146
] |- closefile}}{{}} ifelse % 146
{{{{//stackf exec % 146
 2 % 136
 index % 146
}}}} exch % 146
 4 % 136
 2 % 136
 roll % 146
 3 % 136
 index % 146
 exch % 146
{ exch % 146
 exec % 146
} forall % 146
 pop % 146
 3 % 136
 -1 % 136
 roll % 146
 pop % 146
}metabind def % 146
/ExpectedFileName{ Category/Category findresource % 146
 begin % 146
Key 256 % 134
 string % 146
ResourceFileName end % 146
} bind % 146
 def % 146
/ExistingFileName{/Category findresource % 146
 begin % 146
 256 % 134
 string % 146
 2 % 136
 copy % 146
ResourceFileName dup % 146
status{ pop % 146
 pop % 146
 pop % 146
 pop % 146
 3 % 136
 1 % 136
 roll % 146
 pop % 146
 pop % 146
 //true % 141
}{ pop % 146
currentsystemparams/GenericResourceDir get % 146
 3 % 136
 1 % 136
 roll % 146
//mtgrd{ setsystemparams} stopped % 146
{//systemdict/$error get % 146
/newerror //false % 141
 put % 146
 pop % 146
 pop % 146
 pop % 146
 pop % 146
 //false % 141
}{ResourceFileName <</GenericResourceDir 4 % 136
 -1 % 136
 roll % 146
>> setsystemparams dup % 146
status{ pop % 146
 pop % 146
 pop % 146
 pop % 146
 //true % 141
}{ pop % 146
 //false % 141
} ifelse % 146
} ifelse % 146
} ifelse % 146
 end % 146
} bind % 146
 def % 146
/##{ dup % 146
 10 % 136
 ge % 146
{ 2 % 136
 string % 146
 cvs % 146
}{ 2 % 136
 string % 146
 dup % 146
 0 % 136
 48 % 136
 put % 146
 exch % 146
 1 % 136
 index % 146
 1 % 136
 1 % 136
 getinterval % 146
 cvs % 146
 pop % 146
} ifelse % 146
} bind % 146
 def % 146
/PSResource{{ dup % 146
//dscr writestring % 146
 dup % 146
Category//46KeyToCategory exec % 146
 writestring % 146
//lf writestring % 146
}} bind % 146
 def % 146
/restuples{ exch % 146
{ exch % 146
 2 % 136
 index % 146
 exch % 146
 writestring % 146
 1 % 136
 index % 146
 32 % 136
 write % 146
//CategoryTo46Key exec % 146
 writestring % 146
 2 % 136
 index % 146
 dup % 146
 32 % 136
 write % 146
{ dup % 146
 length % 146
 string % 146
 cvs % 146
 writestring % 146
 2 % 136
 index % 146
{ dup % 146
 () % 142
 ne % 146
{ 1 % 136
 index % 146
 32 % 136
 write % 146
} if % 146
 writestring % 146
 3 % 136
 copy % 146
 2 % 136
 index % 146
 10 % 136
 write % 146
}}} 2 % 136
 index % 146
 6 % 136
 -1 % 136
 roll % 146
 2 % 136
 index % 146
 7 % 136
 -1 % 136
 roll % 146
{ exch % 146
 exec % 146
} forall % 146
 6 % 136
{ pop % 146
} repeat % 146
} bind % 146
 def % 146
/DocumentNeededResources{//dscnr/NeededResources dup % 146
 where % 146
{ exch % 146
 get % 146
}{ pop % 146
{}} ifelse % 146
//dsc+//restuples} bind % 146
 def % 146
/DocumentSuppliedResources{//dscsr/SuppliedResources dup % 146
 where % 146
{ exch % 146
 get % 146
}{ pop % 146
[ Category Key Qualifier ]} ifelse % 146
//dsc+//restuples} bind % 146
 def % 146
/IncludeResource{//dscir/NeededResources dup % 146
 where % 146
{ exch % 146
 get % 146
}{ pop % 146
{}} ifelse % 146
//dscir//restuples} bind % 146
 def % 146
/BeginResource{{ dup % 146
//dscbr writestring % 146
 dup % 146
 32 % 136
 write % 146
 dup % 146
Category//CategoryTo46Key exec % 146
 writestring % 146
 dup % 146
 32 % 136
 write % 146
 dup % 146
Key dup % 146
 length % 146
 string % 146
 cvs % 146
 writestring % 146
 dup % 146
Qualifier dup % 146
 () % 142
 ne % 146
{ 1 % 136
 index % 146
 32 % 136
 write % 146
} if % 146
 writestring % 146
 dup % 146
 32 % 136
 write % 146
 dup % 146
VMusage writestring % 146
 10 % 136
 write % 146
}} bind % 146
 def % 146
/RCSfile{//cosp search % 146
{ pop % 146
 pop % 146
} if % 146
//comv search % 146
{ exch % 146
 pop % 146
 exch % 146
 pop % 146
} if % 146
} bind % 146
 def % 146
/RCSrevision{//cosp search % 146
{ pop % 146
 pop % 146
} if % 146
//sp search % 146
{ exch % 146
 pop % 146
 exch % 146
 pop % 146
} if % 146
} bind % 146
 def % 146
/Major+RCS{//dot search % 146
{//sp 3 % 136
 1 % 136
 roll % 146
 exch % 146
} if % 146
 5 % 136
 -1 % 136
 roll % 146
 10 % 136
 string % 146
 cvs % 146
{ 5 % 136
{ dup % 146
 3 % 136
 -1 % 136
 roll % 146
 writestring % 146
} repeat % 146
 pop % 146
} 32 % 136
//holdstring exec % 146
} bind % 146
 def % 146
/.spre{ exch % 146
{ search % 146
{ 6 % 136
 2 % 136
 roll % 146
 pop % 146
 pop % 146
 pop % 146
 1 % 136
 index % 146
 length % 146
 1 % 136
 add % 146
 1 % 136
 index % 146
 length % 146
 1 % 136
 index % 146
 sub % 146
 getinterval % 146
 3 % 136
 1 % 136
 roll % 146
}{ 4 % 136
 -1 % 136
 roll % 146
 pop % 146
} ifelse % 146
 //true % 141
}{ exch % 146
 pop % 146
 search % 146
} ifelse % 146
} bind % 146
 def % 146
/.sphtlfsearch{ dup % 146
 dup % 146
//sp search % 146
//ht//.spre exec % 146
//lf//.spre exec % 146
} bind % 146
 def % 146
/trimleft{ dup % 146
 0 % 136
 exch % 146
{ dup % 146
 32 % 136
 ne % 146
 exch % 146
 dup % 146
 9 % 136
 ne % 146
 exch % 146
 10 % 136
 ne % 146
 and % 146
 and % 146
{ exit % 146
} if % 146
 1 % 136
 add % 146
} forall % 146
 dup % 146
 neg % 146
 2 % 136
 index % 146
 length % 146
 add % 146
 getinterval % 146
} bind % 146
 def % 146
/DSCtext{//trimleft exec % 146
 dup % 146
 () % 142
 eq % 146
{ dup % 146
}{ dup % 146
 0 % 136
 get % 146
 40 % 136
 eq % 146
{ token % 146
 pop % 146
}{ dup % 146
//.sphtlfsearch exec % 146
 not % 146
{ pop % 146
 () % 142
 exch % 146
}{ exch % 146
 pop % 146
 exch % 146
 pop % 146
 exch % 146
 1 % 136
 index % 146
 length % 146
 dup % 146
 neg % 146
 2 % 136
 index % 146
 length % 146
 add % 146
 getinterval % 146
 exch % 146
} ifelse % 146
} ifelse % 146
} ifelse % 146
} bind % 146
 def % 146
/DSCqualifier?{//trimleft exec % 146
 dup % 146
 () % 142
 eq % 146
{ dup % 146
}{ dup % 146
 0 % 136
 get % 146
 dup % 146
 48 % 136
 lt % 146
 exch % 146
 57 % 136
 gt % 146
 or % 146
{ () % 142
}{ dup % 146
 token % 146
 not % 146
{ () % 142
}{ type % 146
 dup % 146
/realtype ne % 146
 exch % 146
/integertype ne % 146
 and % 146
{ pop % 146
 () % 142
}{//trimleft exec % 146
 dup % 146
 0 % 136
 get % 146
 dup % 146
 48 % 136
 lt % 146
 exch % 146
 57 % 136
 gt % 146
 or % 146
{ pop % 146
 () % 142
}{ token % 146
 not % 146
{ () % 142
}{ dup % 146
 type % 146
/integertype ne % 146
{ pop % 146
 pop % 146
 () % 142
}{ 0 % 136
 lt % 146
{ pop % 146
 () % 142
}{ exch % 146
 0 % 136
 1 % 136
 index % 146
 length % 146
 3 % 136
 index % 146
 length % 146
 sub % 146
 2 % 136
 index % 146
 1 % 136
 index % 146
 1 % 136
 sub % 146
 get % 146
 dup % 146
 48 % 136
 lt % 146
 exch % 146
 57 % 136
 gt % 146
 or % 146
{ 1 % 136
 sub % 146
 2 % 136
 index % 146
 1 % 136
 index % 146
 6 % 136
 -1 % 136
 roll % 146
 length % 146
 1 % 136
 add % 146
 getinterval % 146
 4 % 136
 1 % 136
 roll % 146
} if % 146
 getinterval % 146
} ifelse % 146
} ifelse % 146
} ifelse % 146
} ifelse % 146
} ifelse % 146
} ifelse % 146
} ifelse % 146
} ifelse % 146
} bind % 146
 def % 146
/DSCresources{ exch % 146
//trimleft exec % 146
//.sphtlfsearch exec % 146
{//46KeyToCategory exec % 146
 cvn % 146
 exch % 146
 pop % 146
 exch % 146
{ 1 % 136
 index % 146
 exch % 146
//DSCtext exec % 146
 dup % 146
 () % 142
 eq % 146
{ pop % 146
 exit % 146
} if % 146
 cvn % 146
 exch % 146
//DSCqualifier? exec % 146
 exch % 146
 4 % 136
 1 % 136
 roll % 146
 5 % 136
 index % 146
 6 % 136
 3 % 136
//hvhide+ap exec % 146
} loop % 146
 exch % 146
 pop % 146
} if % 146
 pop % 146
 pop % 146
 pop % 146
} bind % 146
 def % 146
/DSCscan{ dup % 146
/Pushback 2 % 136
 copy % 146
 known % 146
{ pop % 146
 pop % 146
}{ 4 % 136
 string % 146
 put % 146
} ifelse % 146
 dup % 146
/Status 2 % 136
 copy % 146
 known % 146
{ pop % 146
 pop % 146
}{ 4 % 136
 array % 146
 put % 146
} ifelse % 146
 dup % 146
/Callbacks get % 146
 dup % 146
 length % 146
 dict % 146
 copy % 146
 1 % 136
 index % 146
/Keywords 3 % 136
 -1 % 136
 roll % 146
 put % 146
{ 2 % 136
 copy % 146
/DSCDecode extfilter flushfile % 146
 dup % 146
/Callbacks get % 146
 1 % 136
 index % 146
/Status get % 146
 0 % 136
 get % 146
 2 % 136
 copy % 146
 known % 146
 not % 146
{ pop % 146
 pop % 146
 pop % 146
 exit % 146
}{ get % 146
 dup % 146
 0 % 136
 get % 146
{ 1 % 136
 index % 146
/Keywords get % 146
 2 % 136
 index % 146
/Status get % 146
 0 % 136
 get % 146
 undef % 146
} if % 146
 dup % 146
 2 % 136
 get % 146
 exch % 146
 2 % 136
 index % 146
/Status get % 146
 1 % 136
 get % 146
 exch % 146
 1 % 136
 get % 146
{{//lf search % 146
{ exch % 146
 pop % 146
 2 % 136
 index % 146
 5 % 136
 1 % 136
//hvhide+ap exec % 146
}{ 1 % 136
 index % 146
 4 % 136
 1 % 136
//hvhide+ap exec % 146
 exit % 146
} ifelse % 146
} loop % 146
 pop % 146
}{ exch % 146
 3 % 136
 1 % 136
//hvhide+ap exec % 146
} ifelse % 146
} ifelse % 146
 dup % 146
/NestDepth 1 % 136
 index % 146
/Status get % 146
 3 % 136
 get % 146
 put % 146
} loop % 146
} bind % 146
 def % 146
/Precedes{ dup % 146
 1 % 136
 2 % 136
 copy % 146
 get % 146
 1 % 136
 add % 146
 put % 146
 exch % 146
 2 % 136
 array % 146
//enq exec % 146
 astore % 146
 pop % 146
} bind % 146
 def % 146
/Release{{ dup % 146
//deq exec % 146
 not % 146
{ pop % 146
 exit % 146
} if % 146
 0 % 136
 get % 146
 1 % 136
 2 % 136
 copy % 146
 get % 146
 1 % 136
 sub % 146
 dup % 146
 0 % 136
 eq % 146
{ 2 % 136
 index % 146
 5 % 136
 index % 146
 2 % 136
 array % 146
//enq exec % 146
 astore % 146
 pop % 146
} if % 146
 put % 146
} loop % 146
} bind % 146
 def % 146
/ResourceDescr{ 3 % 136
 copy % 146
 exch % 146
 2 % 136
 copy % 146
 known % 146
{ get % 146
}{ 1 % 136
 dict % 146
 dup % 146
 4 % 136
 1 % 136
 roll % 146
 put % 146
} ifelse % 146
 exch % 146
 2 % 136
 copy % 146
 known % 146
{ get % 146
 4 % 136
 1 % 136
 roll % 146
 pop % 146
 pop % 146
 pop % 146
 //false % 141
}{ null % 146
 0 % 136
 7 % 136
 -3 % 136
 roll % 146
 pop % 146
 () % 142
 null % 146
 6 % 136
 array % 146
 astore % 146
 dup % 146
 4 % 136
 1 % 136
 roll % 146
 put % 146
 //true % 141
} ifelse % 146
} bind % 146
 def % 146
/.qme{/net.anastigmatix.QualifierMismatch//errorstop exec % 146
} bind % 146
 def % 146
/ResourceAddPrereq{ 3 % 136
 1 % 136
 roll % 146
 exch % 146
 6 % 136
 index % 146
//ResourceDescr exec % 146
{ dup % 146
 4 % 136
 4 % 136
 -1 % 136
 roll % 146
 put % 146
 dup % 146
 4 % 136
 index % 146
 2 % 136
 array % 146
//enq exec % 146
 astore % 146
 pop % 146
}{ dup % 146
 5 % 136
 get % 146
 dup % 146
 null % 146
 eq % 146
{ pop % 146
}{ 2 % 136
 index % 146
 5 % 136
 index % 146
 exec % 146
 not % 146
//.qme if % 146
} ifelse % 146
 dup % 146
 4 % 136
 get % 146
 2 % 136
 index % 146
 2 % 136
 copy % 146
 7 % 136
 index % 146
 exec % 146
{ pop % 146
 pop % 146
 exch % 146
 pop % 146
}{ exch % 146
 5 % 136
 index % 146
 exec % 146
 not % 146
//.qme if % 146
 dup % 146
 4 % 136
 4 % 136
 -1 % 136
 roll % 146
 put % 146
} ifelse % 146
} ifelse % 146
 2 % 136
 copy % 146
 exch % 146
//Precedes exec % 146
 pop % 146
} bind % 146
 def % 146
/ResourceSupply{ exch % 146
 3 % 136
 index % 146
 2 % 136
 get % 146
 ne % 146
 3 % 136
 -1 % 136
 roll % 146
 3 % 136
 index % 146
 3 % 136
 get % 146
 ne % 146
 or % 146
{ pop % 146
}{ 1 % 136
 index % 146
 5 % 136
 get % 146
 null % 146
 ne % 146
{ 1 % 136
 index % 146
/net.anastigmatix.ResourceMultiplySupplied//errorstop exec % 146
} if % 146
 dup % 146
 2 % 136
 index % 146
 4 % 136
 get % 146
 4 % 136
 index % 146
 exec % 146
 not % 146
//.qme if % 146
 1 % 136
 index % 146
 exch % 146
 5 % 136
 exch % 146
 put % 146
} ifelse % 146
} bind % 146
 def % 146
/rnresdict <</HeaderOnly true/NestDepth 1 % 136
/Callbacks <<//dscnr [ true true{//ResourceAddPrereq//DSCresources exec % 146
} bind % 146
] readonly//dscsr [ true true{//ResourceSupply//DSCresources exec % 146
} bind % 146
] readonly >> readonly >> readonly def % 146
/ReadNeededFromFS{{ 1 % 136
 index % 146
//deq exec % 146
 not % 146
{ pop % 146
 pop % 146
 exit % 146
} if % 146
 0 % 136
 get % 146
 dup % 146
 2 % 136
 get % 146
 1 % 136
 index % 146
 3 % 136
 get % 146
//ExistingFileName exec % 146
 not % 146
{/undefined//errorstop exec % 146
}{//rfile exec % 146
//rnresdict dup % 146
 length % 146
 dict % 146
 copy % 146
//DSCscan exec % 146
closefile dup % 146
 1 % 136
 get % 146
 0 % 136
 gt % 146
{ pop % 146
}{ 4 % 136
 index % 146
 2 % 136
 array % 146
//enq exec % 146
 astore % 146
 pop % 146
} ifelse % 146
} ifelse % 146
} loop % 146
} bind % 146
 def % 146
/QualifierSatisfies{ token % 146
 not % 146
{ pop % 146
 //true % 141
}{ 3 % 136
 -1 % 136
 roll % 146
 token % 146
 not % 146
{ pop % 146
 pop % 146
 //false % 141
}{ 3 % 136
 -1 % 136
 roll % 146
 2 % 136
 copy % 146
 gt % 146
{ pop % 146
 pop % 146
 pop % 146
 pop % 146
 //true % 141
}{ lt % 146
{ pop % 146
 pop % 146
 //false % 141
}{ exch % 146
 token % 146
 not % 146
{ pop % 146
 //true % 141
}{ exch % 146
 pop % 146
 exch % 146
 token % 146
 not % 146
{ pop % 146
 //false % 141
}{ exch % 146
 pop % 146
 le % 146
} ifelse % 146
} ifelse % 146
} ifelse % 146
} ifelse % 146
} ifelse % 146
} ifelse % 146
} bind % 146
 def % 146
/.crf{ 1 % 136
 index % 146
 2 % 136
 get % 146
 2 % 136
 index % 146
 3 % 136
 get % 146
//ExistingFileName exec % 146
 not % 146
{/undefined//errorstop exec % 146
} if % 146
//rfile exec % 146
 dup % 146
 2 % 136
 index % 146
//copyfile exec % 146
closefile} bind % 146
 def % 146
/.fr{ dup % 146
-| [ (\n/) % 142
readonly ] |- writestring % 146
 dup % 146
 2 % 136
 index % 146
 2 % 136
 get % 146
 dup % 146
 length % 146
 string % 146
 cvs % 146
 writestring % 146
 dup % 146
-| [ ( /) % 142
readonly ] |- writestring % 146
 dup % 146
 2 % 136
 index % 146
 3 % 136
 get % 146
 dup % 146
 length % 146
 string % 146
 cvs % 146
 writestring % 146
 dup % 146
-| [ ( findresource\n) % 142
readonly ] |- writestring % 146
}metabind def % 146
/.vmr (\n2 vmreclaim 2 vmreclaim -2 vmreclaim\n) % 142
readonly def % 146
/.vms (\nfalse setglobal vmstatus pop exch pop\ntrue setglobal vmstatus pop exch pop add\n) % 142
readonly def % 146
/VMquery{ 1 % 136
 index % 146
 type % 146
/nametype eq % 146
{//QualifierSatisfies exch % 146
} if % 146
 1 % 136
 array % 146
 1 % 136
 dict % 146
 1 % 136
 array % 146
 7 % 136
 -2 % 136
 roll % 146
 3 % 136
 index % 146
//ResourceDescr exec % 146
 pop % 146
 6 % 136
 1 % 136
 roll % 146
 5 % 136
 index % 146
 1 % 136
 index % 146
 2 % 136
 array % 146
//enq exec % 146
 astore % 146
 pop % 146
 5 % 136
 -1 % 136
 roll % 146
//ReadNeededFromFS exec % 146
 pop % 146
 1 % 136
 index % 146
-| [ (%!\ntrue setglobal\n) % 142
readonly ] |- writestring % 146
{ dup % 146
//deq exec % 146
 pop % 146
 0 % 136
 get % 146
 dup % 146
 4 % 136
 index % 146
 eq % 146
{ pop % 146
 pop % 146
 exit % 146
} if % 146
 2 % 136
 index % 146
//.crf exec % 146
//.fr exec % 146
 pop % 146
//Release exec % 146
} loop % 146
 dup % 146
//.vmr writestring % 146
 dup % 146
//.vms writestring % 146
//.crf exec % 146
//.fr exec % 146
 dup % 146
-| [ (exch ) % 142
readonly ] |- writestring % 146
 dup % 146
//.vms writestring % 146
 dup % 146
-| [ (1 index sub\n) % 142
readonly ] |- writestring % 146
 dup % 146
//.vmr writestring % 146
 dup % 146
//.vms writestring % 146
 dup % 146
-| [ (2 index sub\n) % 142
readonly ] |- writestring % 146
//.crf exec % 146
//.fr exec % 146
 dup % 146
-| [ (4 1 roll ) % 142
readonly ] |- writestring % 146
 dup % 146
//.vms writestring % 146
 dup % 146
-| [ (\n1 index sub 3 index sub 3 -1 roll\n\(/VMusage \\\(\) print 16 string cvs print \( \) print 16 string cvs print\n\(\\\) def\n/VMafterGC \\\(\) print 16 string cvs print \(\\\) def\n\) print flush\n) % 142
readonly ] |- writestring % 146
 pop % 146
 pop % 146
}metabind def % 146
{/atload/tokenwriter/copytokens/CategoryTo46Key/46KeyToCategory/cpath/pathprep/wmdict/text/stackf/fstack/ExpectedFileName/ExistingFileName/##/PSResource/DocumentNeededResources/DocumentSuppliedResources/IncludeResource/BeginResource/PackagerIdent/RCSfile/RCSrevision/Major+RCS/trimleft/DSCtext/DSCqualifier?/DSCresources/DSCscan/Precedes/Release/RD_LEN/OR_FOLQ/OR_NPREQ/RD_KEY/RD_CAT/RD_NQUAL/RD_SQUAL/QualifierSatisfies/ResourceDescr/ResourceAddPrereq/rnresdict/ReadNeededFromFS/VMquery/extfilter/\markup} export/net.anastigmatix.Packager exch % 146
/ProcSet defineresource pop % 146
setpacking end % 146
 end % 146
 end % 146
 end % 146
